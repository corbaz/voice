// ============================================
// üìÅ config.js - Configuraci√≥n Centralizada
// ============================================
const AppConfig = {
  VERSION: "2.6",
  GROQ_BASE_URL: "https://api.groq.com/openai/v1",
  DEFAULT_GROQ_API_KEY: "gsk_...",
  MODELS: {
    WHISPER: "whisper-large-v3",
    LLM: "meta-llama/llama-4-maverick-17b-128e-instruct"
  },
  HISTORY_LIMIT: 20,
  TTS: {
    RATE: 1.0,
    DEFAULT_LANG: {
      ES: "es-ES",
      EN: "en-US"
    }
  }
};

// ============================================
// üìÅ services/StorageService.js
// ============================================
class StorageService {
  constructor(storageKey) {
    this.storageKey = storageKey;
  }

  load() {
    try {
      const data = localStorage.getItem(this.storageKey);
      return data ? JSON.parse(data) : [];
    } catch (error) {
      console.error("Error loading from storage:", error);
      return [];
    }
  }

  save(data) {
    try {
      localStorage.setItem(this.storageKey, JSON.stringify(data));
      return true;
    } catch (error) {
      console.error("Error saving to storage:", error);
      return false;
    }
  }

  clear() {
    localStorage.removeItem(this.storageKey);
  }
}

// ============================================
// üìÅ services/GroqAPIService.js
// ============================================
class GroqAPIService {
  constructor(apiKey, baseUrl) {
    this.apiKey = apiKey;
    this.baseUrl = baseUrl;
  }

  async transcribe(audioBlob, language = "es") {
    const formData = new FormData();
    const file = new File([audioBlob], "audio.webm", { type: "audio/webm" });
    formData.append("file", file);
    formData.append("model", AppConfig.MODELS.WHISPER);
    formData.append("response_format", "text");
    formData.append("language", language);

    const response = await fetch(`${this.baseUrl}/audio/transcriptions`, {
      method: "POST",
      headers: { "Authorization": `Bearer ${this.apiKey}` },
      body: formData
    });

    if (!response.ok) {
      throw new Error(`Transcription error: ${await response.text()}`);
    }

    return await response.text();
  }

  async chat(messages, temperature = 0.3) {
    const response = await fetch(`${this.baseUrl}/chat/completions`, {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${this.apiKey}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model: AppConfig.MODELS.LLM,
        messages,
        temperature
      })
    });

    if (!response.ok) {
      throw new Error(`Chat error: ${await response.text()}`);
    }

    const data = await response.json();
    return data.choices?.[0]?.message?.content ?? "";
  }
}

// ============================================
// üìÅ services/AudioRecorderService.js
// ============================================
class AudioRecorderService {
  constructor() {
    this.mediaRecorder = null;
    this.chunks = [];
    this.stream = null;
  }

  async startRecording() {
    if (!navigator.mediaDevices?.getUserMedia) {
      throw new Error("MediaDevices API not available");
    }

    this.stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    this.mediaRecorder = new MediaRecorder(this.stream);
    this.chunks = [];

    return new Promise((resolve, reject) => {
      this.mediaRecorder.ondataavailable = (e) => {
        if (e.data.size > 0) this.chunks.push(e.data);
      };

      this.mediaRecorder.onstop = () => {
        const blob = new Blob(this.chunks, { type: "audio/webm" });
        this.stopStream();
        resolve(blob);
      };

      this.mediaRecorder.onerror = (error) => {
        this.stopStream();
        reject(error);
      };

      this.mediaRecorder.start();
    });
  }

  stopRecording() {
    if (this.mediaRecorder && this.mediaRecorder.state === "recording") {
      this.mediaRecorder.stop();
    }
  }

  stopStream() {
    if (this.stream) {
      this.stream.getTracks().forEach(track => track.stop());
      this.stream = null;
    }
  }

  isRecording() {
    return this.mediaRecorder?.state === "recording";
  }
}

// ============================================
// üìÅ services/TTSService.js
// ============================================
class TTSService {
  constructor() {
    this.synthesis = window.speechSynthesis;
    this.voices = [];
    this.loadVoices();
  }

  loadVoices() {
    this.voices = this.synthesis.getVoices();
    this.synthesis.onvoiceschanged = () => {
      this.voices = this.synthesis.getVoices();
    };
  }

  getVoicesByLanguage(langCode) {
    return this.voices.filter(v => v.lang.startsWith(langCode));
  }

  findBestVoice(langCode, voiceName = null) {
    // 1. Intentar encontrar voz espec√≠fica por nombre
    if (voiceName) {
      const voice = this.voices.find(v => v.name === voiceName);
      if (voice && voice.lang.startsWith(langCode)) return voice;
    }

    // 2. Buscar voz exacta del idioma (ej. es-ES)
    const exactLang = AppConfig.TTS.DEFAULT_LANG[langCode.toUpperCase()];
    let voice = this.voices.find(v => v.lang === exactLang);
    if (voice) return voice;

    // 3. Cualquier voz que empiece con el c√≥digo
    voice = this.voices.find(v => v.lang.startsWith(langCode));
    return voice || null;
  }

  speak(text, langCode, voiceName = null, rate = 1.0) {
    return new Promise((resolve, reject) => {
      this.synthesis.cancel();

      const utterance = new SpeechSynthesisUtterance(text);
      const voice = this.findBestVoice(langCode, voiceName);

      if (voice) {
        utterance.voice = voice;
        utterance.lang = voice.lang;
      } else {
        utterance.lang = AppConfig.TTS.DEFAULT_LANG[langCode.toUpperCase()] || "es-ES";
      }

      utterance.rate = rate;
      utterance.onend = () => resolve();
      utterance.onerror = (e) => reject(e);

      this.synthesis.speak(utterance);
    });
  }

  stop() {
    this.synthesis.cancel();
  }
}

// ============================================
// üìÅ models/ConversationHistory.js
// ============================================
class ConversationHistory {
  constructor(storageService, maxSize = 20) {
    this.storageService = storageService;
    this.maxSize = maxSize;
    this.messages = this.storageService.load();
  }

  add(role, content) {
    this.messages.push({ role, content });
    this.trim();
    this.storageService.save(this.messages);
  }

  trim() {
    if (this.messages.length > this.maxSize) {
      this.messages = this.messages.slice(-this.maxSize);
    }
  }

  clear() {
    this.messages = [];
    this.storageService.clear();
  }

  getAll() {
    return [...this.messages];
  }

  size() {
    return this.messages.length;
  }
}

// ============================================
// üìÅ utils/Logger.js
// ============================================
class Logger {
  constructor(logElement) {
    this.logElement = logElement;
  }

  log(message, level = "info") {
    const timestamp = new Date().toLocaleTimeString();
    const formattedMsg = `[${timestamp}] ${message}`;
    
    console.log(formattedMsg);
    
    if (this.logElement) {
      this.logElement.textContent += formattedMsg + "\n";
      this.logElement.scrollTop = this.logElement.scrollHeight;
    }
  }

  error(message) {
    this.log(`‚ùå ERROR: ${message}`, "error");
  }

  success(message) {
    this.log(`‚úÖ ${message}`, "success");
  }

  clear() {
    if (this.logElement) {
      this.logElement.textContent = "";
    }
  }
}

// ============================================
// üìÅ controllers/AppController.js
// ============================================
class AppController {
  constructor() {
    this.initializeServices();
    this.initializeUI();
    this.setupEventListeners();
  }

  initializeServices() {
    this.logger = new Logger(document.getElementById("log"));
    this.storageService = new StorageService("voiceAppHistory");
    this.history = new ConversationHistory(this.storageService);
    this.audioRecorder = new AudioRecorderService();
    this.ttsService = new TTSService();
    this.groqAPI = null; // Se inicializa con la API key
  }

  initializeUI() {
    // Elementos DOM
    this.elements = {
      apiKeyInput: document.getElementById("apiKey"),
      recordBtn: document.getElementById("recordBtn"),
      stopBtn: document.getElementById("stopBtn"),
      stopTTSBtn: document.getElementById("stopTTSBtn"),
      recordStatus: document.getElementById("recordStatus"),
      transcriptionEl: document.getElementById("transcription"),
      askBtn: document.getElementById("askBtn"),
      llmResponseEl: document.getElementById("llmResponse"),
      ttsBtn: document.getElementById("ttsBtn"),
      autoModeCheckbox: document.getElementById("autoMode"),
      clearHistoryBtn: document.getElementById("clearHistoryBtn"),
      historyStatusEl: document.getElementById("historyStatus"),
      voicesEsSelect: document.getElementById("voicesEs"),
      voicesEnSelect: document.getElementById("voicesEn")
    };

    this.updateHistoryStatus();
    this.populateVoiceLists();
  }

  setupEventListeners() {
    this.elements.recordBtn.onclick = () => this.handleRecord();
    this.elements.stopBtn.onclick = () => this.handleStopRecord();
    this.elements.askBtn.onclick = () => this.handleAskLLM();
    this.elements.ttsBtn.onclick = () => this.handlePlayTTS();
    this.elements.stopTTSBtn.onclick = () => this.handleStopTTS();
    this.elements.clearHistoryBtn.onclick = () => this.handleClearHistory();
  }

  // ========== Handlers ==========

  async handleRecord() {
    try {
      this.updateRecordStatus("Solicitando micr√≥fono...", "yellow");
      this.logger.log("Iniciando grabaci√≥n...");

      const audioPromise = this.audioRecorder.startRecording();
      
      this.elements.recordBtn.disabled = true;
      this.elements.stopBtn.disabled = false;
      this.updateRecordStatus("Grabando... üî¥", "red", true);

      const blob = await audioPromise;
      this.logger.success(`Grabaci√≥n completada: ${blob.size} bytes`);
      await this.handleTranscription(blob);

    } catch (error) {
      this.logger.error(`Micr√≥fono: ${error.message}`);
      this.updateRecordStatus(`Error: ${error.message}`, "red");
      alert(`Error al acceder al micr√≥fono:\n${error.message}`);
    } finally {
      this.elements.recordBtn.disabled = false;
      this.elements.stopBtn.disabled = true;
    }
  }

  handleStopRecord() {
    this.audioRecorder.stopRecording();
    this.updateRecordStatus("Procesando...", "yellow");
  }

  async handleTranscription(audioBlob) {
    try {
      this.updateRecordStatus("Transcribiendo...", "yellow");
      this.initializeGroqAPI();

      const text = await this.groqAPI.transcribe(audioBlob, "es");
      this.elements.transcriptionEl.value = text;
      this.logger.success("Transcripci√≥n completa");
      this.updateRecordStatus("Transcripci√≥n lista ‚úÖ", "green");

      if (this.elements.autoModeCheckbox.checked && text.trim()) {
        await this.handleAskLLM();
      }

    } catch (error) {
      this.logger.error(`Transcripci√≥n: ${error.message}`);
      this.updateRecordStatus("Error ‚ùå", "red");
    }
  }

  async handleAskLLM() {
    const inputText = this.elements.transcriptionEl.value.trim();
    if (!inputText) {
      alert("No hay texto para enviar al LLM.");
      return;
    }

    try {
      this.logger.log("Enviando al LLM...");
      this.initializeGroqAPI();

      const isEnglish = document.querySelector('input[name="lang"][value="en"]').checked;
      const systemPrompt = this.buildSystemPrompt(isEnglish);
      const messages = this.buildChatMessages(systemPrompt, inputText, isEnglish);

      const reply = await this.groqAPI.chat(messages);
      
      this.elements.llmResponseEl.value = reply;
      this.logger.success("Respuesta del LLM recibida");

      this.history.add("user", inputText);
      this.history.add("assistant", reply);
      this.updateHistoryStatus();

      if (this.elements.autoModeCheckbox.checked && reply.trim()) {
        await this.handlePlayTTS();
      }

    } catch (error) {
      this.logger.error(`LLM: ${error.message}`);
    }
  }

  async handlePlayTTS() {
    const text = this.elements.llmResponseEl.value.trim();
    if (!text) {
      alert("No hay texto para convertir a voz.");
      return;
    }

    try {
      const isEnglish = document.querySelector('input[name="lang"][value="en"]').checked;
      const langCode = isEnglish ? "en" : "es";
      const voiceSelect = isEnglish ? this.elements.voicesEnSelect : this.elements.voicesEsSelect;
      const voiceName = voiceSelect.value;

      this.logger.log(`üó£Ô∏è Reproduciendo con voz: ${voiceName || "Autom√°tica"}`);
      
      await this.ttsService.speak(text, langCode, voiceName);
      this.logger.success("Reproducci√≥n completada");

    } catch (error) {
      this.logger.error(`TTS: ${error.message}`);
    }
  }

  handleStopTTS() {
    this.ttsService.stop();
    this.logger.log("Reproducci√≥n detenida");
  }

  handleClearHistory() {
    this.history.clear();
    this.logger.clear();
    this.logger.log("Historial borrado");
    this.updateHistoryStatus();
  }

  // ========== Helpers ==========

  initializeGroqAPI() {
    if (!this.groqAPI) {
      const apiKey = this.elements.apiKeyInput.value.trim();
      if (!apiKey) throw new Error("Falta API key de Groq");
      this.groqAPI = new GroqAPIService(apiKey, AppConfig.GROQ_BASE_URL);
    }
  }

  buildSystemPrompt(isEnglish) {
    return isEnglish
      ? "You are a helpful assistant. You MUST answer in English."
      : "Sos un asistente √∫til. Deb√©s responder SIEMPRE en espa√±ol.";
  }

  buildChatMessages(systemPrompt, userInput, isEnglish) {
    const languageHint = isEnglish ? " (Respond in English)" : " (Responder en espa√±ol)";
    return [
      { role: "system", content: systemPrompt },
      ...this.history.getAll(),
      { role: "user", content: userInput + languageHint }
    ];
  }

  updateRecordStatus(text, color, pulse = false) {
    this.elements.recordStatus.textContent = `Estado: ${text}`;
    this.elements.recordStatus.className = `text-center text-sm text-${color}-400 font-mono`;
    if (pulse) this.elements.recordStatus.classList.add("animate-pulse");
  }

  updateHistoryStatus() {
    this.elements.historyStatusEl.textContent = 
      `Mensajes en memoria: ${this.history.size()}`;
  }

  populateVoiceLists() {
    const espanolVoices = this.ttsService.getVoicesByLanguage("es");
    const englishVoices = this.ttsService.getVoicesByLanguage("en");

    this.populateVoiceSelect(this.elements.voicesEsSelect, espanolVoices, "ES");
    this.populateVoiceSelect(this.elements.voicesEnSelect, englishVoices, "EN");
  }

  populateVoiceSelect(selectElement, voices, defaultLabel) {
    selectElement.innerHTML = "";
    
    if (voices.length === 0) {
      const opt = document.createElement("option");
      opt.textContent = `Predeterminada (${defaultLabel})`;
      opt.value = "";
      selectElement.appendChild(opt);
      return;
    }

    voices.forEach(voice => {
      const option = document.createElement("option");
      option.textContent = `${voice.name} (${voice.lang})`;
      option.value = voice.name;
      selectElement.appendChild(option);
    });
  }
}

// ============================================
// üìÅ main.js - Punto de Entrada
// ============================================
document.addEventListener('DOMContentLoaded', () => {
  // Mostrar versi√≥n
  const versionEl = document.getElementById('appVersion');
  if (versionEl) versionEl.textContent = `v${AppConfig.VERSION}`;

  // Inicializar aplicaci√≥n
  const app = new AppController();
  
  console.log("‚úÖ JCC Voice AI inicializado correctamente");
});